<?php
/* кука на один час */
setcookie("TestCookie", Vasya, time()+3600);
/* читаем куки */
echo $_COOKIE['TestCookie'];
?>





<?php
/* А что если мы хотим передать туда массив, ну чтобы, 
например, не посылать десять кук, а передать все значения массивом. 
Массив же – это не строковое значение! Для этого нам понадобится массив 
перевести в строку. Сделать это можно с помощью функции serialize(). */
$arr = array("one"=>1,
			 2=>"two",
			 3=>true);
$str_arr = serialize($arr);
setcookie("TestCookie", $str_arr);
/* Чтобы обратно распаковать строку, используется функция unserialize(). */
?>





<?php
/*
создаем переменную счетчик и присваиваем
значение ноль
*/
 
$counter = 0;
 
/*
проверяем, есть ли такая кука со счетчиком.
если да, присваиваем значение этой куки переменной счетчику
*/
 
if(isset($_COOKIE['counter']))
	$counter = $_COOKIE['counter'];
 
/* каждый раз увеличиваем счетчик на единицу */
 
$counter++;
 
/*
проверяем, если ли кука с временем последнего посещения.
если да, присваиваем эту куку переменной
*/
 
if(isset($_COOKIE['time_last_visit']))
	$time_last_visit = $_COOKIE['time_last_visit'];
 
/* устанавливаем куки на всю жизнь */
 
setcookie("counter", $counter, 0x7FFFFFFF);
setcookie("time_last_visit", date("d-m-Y H:i:s"), 0x7FFFFFFF);
 
/* выводим куки */
 
if($counter == 1)
	echo "Добро пожаловать!";
else{
	echo "Вы пришли $counter раз!<br>";
	echo "Последнее посещение $time_last_visit";
}
?>




<?php
/* Есть еще один пример использования этого заголовка – у нас есть обычная форма
 ввода данных (имя и возраст). Мы вбиваем данные и нажимаем кнопку отправить. Данные 
 уходят, например, записываются в базу данных. Что будет, если мы после отправки данных 
 нажмем F5? Браузер скажет нам – там содержатся введенные данные, повторить запрос? Да, 
 повторить! И наши данные опять запишутся в базу данных. Хм, а что будет, если F5 будет 
 нажимать пользователь, у которого мы запрашиваем эти данные? А данные будут записываться
  в нашу базу, пока она не треснет. Так вот, с помощью заголовка Location от этого можно
   избавиться, поставив этот заголовок после принятия всех данных и сделать переадресацию 
   на тот же файл, где расположена форма. После этого пользователь уже не сможет перепослать 
   нам данные кнопкой F5 и замусорить нам нашу базу данных: */
header("Location: ".$_SERVER['PHP_SELF']);
?>





Следующий полезный заголовок HEAD – это заголовок Refresh. Записывается он так:

<?php
header("Refresh: 1");
?>

Что означает этот заголовок и цифра в его значении? Все очень просто. Этот заголовок говорит браузеру,
 чтобы он (браузер) перезагружал страницу через то количество секунд, которые указаны в его значении. 
 Если мы напишем такой код, то страница будет перезагружаться через каждые пять секунд:

<?php
header("Refresh: 5");
?>
<h1><?=date("H:i:s")?></h1>

Такой заголовок в основном применяется в онлайн трансляциях футбольных или еще каких-нибудь матчей. 
Когда сидит комментатор и отписывается каждые, например, 30 секунд о ходе матча и чтобы пользователю каждый 
раз не тыкать F5 и не обновлять страницу и применяется этот заголовок. С помощью этого заголовка можно еще
 сделать вот такую вещь – аналог заголовка location, но с задержкой. То есть мы можем в значении заголовка 
 refresh поставить второй параметр (URL) – куда «рефрешить» нашу страницу:

<?php
header("Refresh: 5; url=http://new_domain.com");
?>
<h1><?php echo "Извините, наш сайт переехал на новый домен. Через пять секунд вы будете перенаправлены на него!"?></h1>





<form action="<?=$SERVER['PHP_SELF']?>" method="post">
Пароль:
<input type="password" name="pass"><br>
<input type="submit">
</form>
<?php
/* переменная $p это полученный пароль от пользователя в первый раз, который может храниться, например, в базе данных */
$p = md5(1234);
/*
проверяем, была ли передана форма
*/
if($_SERVER['REQUEST_METHOD'] == POST){
	/* принимаем пароль от пользователя повторно */
	$pass = md5($_POST['pass']);
	/* если повторно введенный пароль совпадает с паролем, который он вводил первый раз, выводим сообщение */
	if($pass == $p)
		echo "Вы вошли в систему!";
}
?>







file_exists(“test.txt”) // существует ли файл

filesize(“test.txt”) // узнать размер файла

fileatime(“test.txt”) // дата последнего обращения к файлу

filemtime(“test.txt”) // дата изменения файла

filectime(“test.txt”) // дата создания файла

функция открытия файла в PHP – fopen(filename, mode),

Режим работы представляет из себя строчку в виде одной буковки.

r – открыть файл только для чтения;

r+ – открыть файл для чтения и записи;

w – открыть файл только для записи. Если он существует, то текущее содержимое файла уничтожается. Текущая позиция устанавливается в начало;

w+ – открыть файл для чтения и записи. Если он существует, то текущее содержимое файла уничтожается. Текущая позиция устанавливается в начало;

a – открыть файл для записи. Текущая позиция устанавливается в конец файла;

a+ – открыть файл для чтения и записи. Текущая позиция устанавливается в конец файла;

b – обрабатывать бинарный файл. Этот флаг необходим при работе с бинарными файлами в OC Windows;

<?php
$f = fopen("data_set.txt", "r") or die("Не удается открыть файл!");
//Здесь работаем с файлом
//Закрываем файл
fclose($f);
?>

читать мы можем с помощью функции fread(«file», length). Туда мы передаем дескриптор файла и длину строки:
<?php
$f = fopen("data_set.txt", "r") or die("Не удается открыть файл!");
echo fread($f, 5);
fclose($f);
?>
Или использовать функцию filesize():
<?php
$f = fopen("data_set.txt", "r") or die("Не удается открыть файл!");
echo fread($f, filesize("data_set.txt"));
fclose($f);
?>
Мы можем зачитать файл построчно.
<?php
$f = fopen("data_set.txt", "r") or die("Не удается открыть файл!");
echo fgets($f); // Выведет Color one
echo fgets($f); // Выведет Color two
fclose($f);
?>
Есть еще одна замечательная функция, которая называется fgetss(). 
Суть ее работы заключается в том, что она читает текст, заключенный в 
HTML тэги и возвращает его уже без HTML тэгов. Сюда также передается дескриптор 
открытого файла, не обязательный второй параметр – это длина строки и, если мы хотим 
сохранить какие-то тэги, то есть тэги, которые эта функция не должна вырезать, то третьим 
параметром мы указываем эти теги, если их несколько, то указывать их надо без пробелов и запятых,
то есть слитно, один за другим. Эта функция так же читает файл построчно.

Далее, мы можем зачитывать файл посимвольно. С помощью функции fgetc().
<?php
$f = fopen("data_set.txt", "r") or die("Не удается открыть файл!");
echo fgetc($f);
fclose($f);
?>

Записывать мы можем с помощью двух функций, вернее одной, другая ее синоним. Вот эти функции: fwrite() и fputs().

<?php
$f = fopen("data_set.txt", "a+") or die("Не удается открыть файл!");
fputs($f, "TEST");
fclose($f);
?>

http://phpblog.su/php-uroven-2/rabota-s-fajlovoj-sistemoj-v-php

Пример гостевой книги:
<?php
/* устанавливаем константу для хранения имени файла */
define("GUEST_LOG", "guest.log");
/* проверяем, была ли отправлена форма */
if($_SERVER['REQUEST_METHOD'] == "POST"){
	/* принимаем имя, которое приходит методом POST и фильтруем его */
	$first_name = trim(strip_tags($_POST['first_name']));
	/* принимаем фамилию, которая приходит методом POST и фильтруем ее */
	$last_name = trim(strip_tags($_POST['last_name']));
	/* формируем строку, которая будет записываться в файл, но прежде проверим есть ли там данные */
	if($first_name and $last_name){
		$user = "$first_name $last_name\n";
	}
	/* записываем строку в файл быстрым способом */
	file_put_contents(GUEST_LOG, $user, FILE_APPEND);
	/* чтобы нам по F5 не накидали повторные данные, мы перезапрашиваем нашу страницу */
	header("Location: file.php");
	/* и в конце ставим exit, чтобы PHP в пустую не выполнял дальше код */
	exit;
}
?>
 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Гостевая книга</title>
</head>
 
<body>
<form action="<?=$_SERVER['PHP_SELF']?>" method="post">
Ваше имя:
<input type="text" name="first_name"><br />
Ваша фамилия:
<input type="text" name="last_name"><br />
<input type="submit">
</form>
</body>
</html>
<?php
/* читаем все из файла, однако первоначально файла нет, поэтому проверяем его на наличие */
if(file_exists(GUEST_LOG)){
	/* читаем содержимое файла в переменную */
	$users = file(GUEST_LOG);
	/* так как переменная $users массив, проверяем – действительно ли это массив и сортируем наши записиси в цикле + 
	в обратном порядке,чтобы новая запись в гостевой книге отображалась выше остальных */
	if(is_array($users)){
		/* делаем записи в обратном порядке */
		$users = array_reverse($users);
		/* выводим в цикле наши данные и ставим им порядковый номер */
		echo "<ol>";
		foreach($users as $user){
		echo "<li>$user</li>";
		}
		echo "</ol>";
	}
}
?>
















